<!DOCTYPE html>
<html><head>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>Bulk RDBMS Upserts with Spring - LPRAKASHV TECH BLOG</title><meta name="viewport" content="width=device-width, initial-scale=1">
  
<script async src="https://www.googletagmanager.com/gtag/js?id=G-EJ9HBFC442"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-EJ9HBFC442');
</script>

	<meta name="description" content="Upsert is a fairly common terminology in databases, meaning Update if the record exists or Insert the new record. Upserts make more sense in case of simple object save requests with new information.
Why Bulk? If we talk about any data sync, data migration or bulk data update jobs, we are bound to have a bulk upsert scenario to update whatever we have in the database and insert all the new rows." />
	<meta property="og:image" content=""/>
	<meta property="og:title" content="Bulk RDBMS Upserts with Spring" />
<meta property="og:description" content="Upsert is a fairly common terminology in databases, meaning Update if the record exists or Insert the new record. Upserts make more sense in case of simple object save requests with new information.
Why Bulk? If we talk about any data sync, data migration or bulk data update jobs, we are bound to have a bulk upsert scenario to update whatever we have in the database and insert all the new rows." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://www.lprakashv.com/posts/2020-08-28_bulk-rdbms-upserts-with-spring/" /><meta property="og:image" content="http://www.lprakashv.com/posts/2020-08-28_bulk-rdbms-upserts-with-spring/images/1.jpeg" /><meta property="og:image" content="http://www.lprakashv.com/posts/2020-08-28_bulk-rdbms-upserts-with-spring/images/2.png" /><meta property="og:image" content="http://www.lprakashv.com/posts/2020-08-28_bulk-rdbms-upserts-with-spring/images/3.png" /><meta property="og:image" content="http://www.lprakashv.com/posts/2020-08-28_bulk-rdbms-upserts-with-spring/images/4.png" /><meta property="og:image" content="http://www.lprakashv.com/posts/2020-08-28_bulk-rdbms-upserts-with-spring/images/5.png" /><meta property="og:image" content="http://www.lprakashv.com/posts/2020-08-28_bulk-rdbms-upserts-with-spring/images/6.png" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-08-28T21:08:07+00:00" />
<meta property="article:modified_time" content="2022-08-13T01:14:56+05:30" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="http://www.lprakashv.com/posts/2020-08-28_bulk-rdbms-upserts-with-spring/images/1.jpeg"/>

<meta name="twitter:title" content="Bulk RDBMS Upserts with Spring"/>
<meta name="twitter:description" content="Upsert is a fairly common terminology in databases, meaning Update if the record exists or Insert the new record. Upserts make more sense in case of simple object save requests with new information.
Why Bulk? If we talk about any data sync, data migration or bulk data update jobs, we are bound to have a bulk upsert scenario to update whatever we have in the database and insert all the new rows."/>
<script src="http://www.lprakashv.com/js/feather.min.js"></script>
	
	
        <link href="http://www.lprakashv.com/css/fonts.b685ac6f654695232de7b82a9143a46f9e049c8e3af3a21d9737b01f4be211d1.css" rel="stylesheet">
	

	
	<link rel="stylesheet" type="text/css" media="screen" href="http://www.lprakashv.com/css/main.c854a9a2c53b1afadf31c3b562cfc34963b1caa5a9def32de484552e8dbdae30.css" />

	
</head>
<body>
      <div class="content-side">
        <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3468549466738898"
     crossorigin="anonymous"></script>

<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3468549466738898"
     data-ad-slot="6861065745"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

      </div>
        <div class="content"><header>
	<div class="main">
		<a href="http://www.lprakashv.com/">LPRAKASHV TECH BLOG</a>
	</div>
	<nav>
		
		<a href="/">Home</a>
		
		<a href="/posts">All posts</a>
		
		<a href="https://github.com/lprakashv/lprakashv">About</a>
		
		<a href="/tags">Tags</a>
		
		
	</nav>
</header>

<main>
	<article>
		<div class="title">
			<h1 class="title">Bulk RDBMS Upserts with Spring</h1>
			<div class="meta">Posted on Aug 28, 2020</div>
		</div>
		

		<section class="body">
      <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3468549466738898"
     crossorigin="anonymous"></script>

<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3468549466738898"
     data-ad-slot="5126431802"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

      
      
      
			<p><img src="/posts/2020-08-28_bulk-rdbms-upserts-with-spring/images/1.jpeg#layoutTextWidth" alt="image"></p>
<p>Upsert is a fairly common terminology in databases, meaning <strong><em>Up</em><strong>date if the record exists or In</strong><em>sert</em></strong> the new record. Upserts make more sense in case of simple object save requests with new information.</p>
<h3 id="why-bulk">Why Bulk?</h3>
<p>If we talk about any <strong><em>data sync</em></strong>, <strong><em>data migration</em></strong> or <strong><em>bulk data update jobs</em></strong>, we are bound to have a bulk upsert scenario to update whatever we have in the database and insert all the new rows.</p>
<h3 id="solutions">Solutions</h3>
<p>We will be discussing about the solutions present in the Spring Boot environment and inferences we make out of them.</p>
<p>For the testing, I will be using MS SQL Server as the database and will be limited to it’s functionality but the concepts are fairly generalisable.</p>
<h4 id="1-standard-saveall-solution-using-spring-jpa">#1 Standard <code>saveAll()</code> Solution using Spring JPA</h4>
<p>Consider we have a <code>price</code> table with a composite unique key/constraints having like with structure:</p>
<p><img src="/posts/2020-08-28_bulk-rdbms-upserts-with-spring/images/2.png#layoutTextWidth" alt="image"></p>
<p>Then, our entity’s composite primary key and entity classes would look like:</p>
<p><img src="/posts/2020-08-28_bulk-rdbms-upserts-with-spring/images/3.png#layoutTextWidth" alt="image"></p>
<p>Assume we are consuming a stream of record batches to upsert. To mock this, we have a supplier to generate a random <code>Price1</code> object batches of size 1000. The ingestion code:</p>
<p><img src="/posts/2020-08-28_bulk-rdbms-upserts-with-spring/images/4.png#layoutTextWidth" alt="image"></p>
<p>Let’s see the results:</p>
<p><img src="/posts/2020-08-28_bulk-rdbms-upserts-with-spring/images/5.png#layoutTextWidth" alt="image"></p>
<p>Now, on looking closely the time taken to persist each batch increases as the table get filled up! What is this?</p>
<p>The culprit is the the method <code>.save()</code> of <code>SimpleJPARepository</code> class:</p>
<p><img src="/posts/2020-08-28_bulk-rdbms-upserts-with-spring/images/6.png#layoutTextWidth" alt="image"></p>
<p>Since, the save performs both the insert and update operation, it has to check whether an entity is “new” or not. For which, it has to either check in the persistence context or query the database, which will get complex in time as the table get filled up.</p>
<h4 id="2-optimisations-for-bulk-save">#2 Optimisations for Bulk save</h4>
<p>Our bottleneck in the previous approach was continuous reads from the DB for a primary key combination to check whether to perform <code>.persist()</code> / insert or <code>.merge()</code> / update.</p>
<p>To avoid additional querying on the table for <code>.isNew()</code> we could have another auto generated unique field (row) which is independent of the business logic. So that, every new object will have a unique id and will always do <code>.persist()</code> for them.</p>
<p>Let’s do the modifications on a completely new table (keeping the business columns as they are), with an additional auto-incremented “identity” column :</p>
<p><img src="/posts/2020-08-28_bulk-rdbms-upserts-with-spring/images/7.png#layoutTextWidth" alt="image"></p>
<p>Here is our entity:</p>
<p><img src="/posts/2020-08-28_bulk-rdbms-upserts-with-spring/images/8.png#layoutTextWidth" alt="image"></p>
<p>Testing out similar ingestion code will yield the result like below:</p>
<p><img src="/posts/2020-08-28_bulk-rdbms-upserts-with-spring/images/9.png#layoutTextWidth" alt="image"></p>
<p>Hooray, Constant time and faster inserts! But wait,</p>
<p><img src="/posts/2020-08-28_bulk-rdbms-upserts-with-spring/images/10.png#layoutTextWidth" alt="image"></p>
<p>There are now duplicate rows with <code>upc, store_id</code> combinations</p>
<p><img src="/posts/2020-08-28_bulk-rdbms-upserts-with-spring/images/11.png#layoutTextWidth" alt="image"></p>
<p>Which is understandable, as we are doing no updates.</p>
<h4 id="3-plain-inserts-then-merge">#3 Plain inserts then merge</h4>
<p>The above 2 experiments have encouraged us to keep the insert model for faster inserts and somehow merge (do updates) later.</p>
<p>To achieve this, we can have a “stage” table having a unique auto-generated id for inserts, separate from our target main table. And a pos-ingestion job for merging the records after de-duplicating.</p>
<p><img src="/posts/2020-08-28_bulk-rdbms-upserts-with-spring/images/12.png#layoutTextWidth" alt="image"></p>
<p>Plain inserts can go as the done above, we will now try to write a “merge” step. This step can very well be database stored procedure due to following reasons:</p>
<ol>
<li>To avoid movement of data and process the bulk data where it resides.</li>
<li>Database specific optimisations are built-in.</li>
</ol>
<p>Following is an example naive implementation of a merge stored procedure for MS SQL, similar merge query features are present most of the mainstream databases.</p>
<p><img src="/posts/2020-08-28_bulk-rdbms-upserts-with-spring/images/13.png#layoutTextWidth" alt="image"></p>
<p>Executing this took less than a second!</p>
<p><img src="/posts/2020-08-28_bulk-rdbms-upserts-with-spring/images/14.png#layoutTextWidth" alt="image"></p>
<p><strong>Important Notes:</strong> The above stored procedure implementation is a very naive approach just to demonstrate and misses on a lot of the aspects to be taken care of in a production environment, like:</p>
<ul>
<li>Over utilising transaction log size due to huge data in the merge statement, **<em>batch-wise merging with id range</em>**could be implemented here.</li>
<li>Monitoring and logging procedure failures, a TRY-CATCH based procedure with logging failures in a <strong><em>procedure-audit logging table</em></strong> could be used.</li>
<li>A successfully merged batch-range delete instead of truncating the stage table.</li>
</ul>
<h4 id="extra-further-improving-batch-inserts">#Extra: Further Improving batch inserts</h4>
<p>If we try to log the hibernate generated SQL statements for our <code>.saveAll()</code> operation, we will get something like this:</p>
<p><img src="/posts/2020-08-28_bulk-rdbms-upserts-with-spring/images/15.png#layoutTextWidth" alt="image"></p>
<p>Here, we are firing single insert statements with values to insert, each going over the network.</p>
<p>There are some improvements that can be done here:</p>
<ol>
<li>Batch the queries and fire in call to the database over network.</li>
<li>Rewrite the single queries into a form of single multi-row query.</li>
</ol>
<p>For first, we can make use of hibernate properties:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>spring.jpa.properties.hibernate.jdbc.batch_size=1000
</span></span><span style="display:flex;"><span>spring.jpa.properties.hibernate.order_inserts=true
</span></span></code></pre></div><p>For second, there are bulk (multi-row) insert query options available in most of the mainstream database solutions (Postgres, MySQL, Oracle). With syntax like:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> myschema.my_table (col1, col2, col3)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">values</span>
</span></span><span style="display:flex;"><span>(val11, val12, val13),
</span></span><span style="display:flex;"><span>(val21, val22, val23),
</span></span><span style="display:flex;"><span>....
</span></span><span style="display:flex;"><span>(valn1, valn2, valn3);
</span></span></code></pre></div><p>While, Postgres and MySQL do support this features with the help of JDBC flag: <strong><em>reWriteBatchedInserts=true</em></strong></p>
<p>But unfortunately, according to <a href="https://docs.microsoft.com/en-us/sql/connect/jdbc/use-bulk-copy-api-batch-insert-operation?view=sql-server-ver15">this resource</a>, ms-sql JDBC driver does not support the multi-row rewrite of the queries. So, if we want to do this, we would have to write the insert queries manually.</p>
<p>Manual insert query creation could look like:</p>
<p><img src="/posts/2020-08-28_bulk-rdbms-upserts-with-spring/images/16.png#layoutTextWidth" alt="image"></p>
<p>The ingestion code would use <code>entityManager.createNativeQuery()</code> method:</p>
<p><img src="/posts/2020-08-28_bulk-rdbms-upserts-with-spring/images/17.png#layoutTextWidth" alt="image"></p>
<p>Let’s test it out:</p>
<p><img src="/posts/2020-08-28_bulk-rdbms-upserts-with-spring/images/18.png#layoutTextWidth" alt="image"></p>
<p>Wow!! Those batches of 1000 records took less than a second, let’s look at the milli seconds now:</p>
<p><img src="/posts/2020-08-28_bulk-rdbms-upserts-with-spring/images/19.png#layoutTextWidth" alt="image"></p>
<!-- raw HTML omitted -->
<h2 id="conclusion">Conclusion</h2>
<p>We can safely infer from our above experiments that:</p>
<ol>
<li>Achieving bulk Upserts are really complicated in relational databases.</li>
<li>Spring JPA and Hibernate provided out-of-the-box save methods won’t scale for huge loads.</li>
<li>A decoupled (from business columns/fields) independent primary key will help improve the insert performance of the inserts, but will eventually insert duplicate records.</li>
<li>Separating insert-only and read (actual) table can be used to improve ingestion performance.</li>
<li>A post insert, merge strategy can be used for de-duplicating inserted records. Stored procedures work well in this scenario.</li>
<li>Native SQL queries will give the most performant result, use solutions which are as close to the database as possible where performance is critical.</li>
</ol>
<h3 id="testing-environment">Testing Environment</h3>
<ul>
<li>Macbook Pro 2016 model 15&quot; with 16 GB RAM.</li>
<li>Application uses Java 1.8 with Spring Boot 2.3.3.</li>
<li>MS SQL server 2017 database in a Docker container.</li>
</ul>
<p>Thanks for Reading :)</p>

      <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3468549466738898"
     crossorigin="anonymous"></script>

<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3468549466738898"
     data-ad-slot="5126431802"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

		</section>

		<div class="post-tags">
			
			
			<nav class="nav tags">
				<ul class="tags">
					
					<li><a href="/tags/java">java</a></li>
					
					<li><a href="/tags/spring-boot">spring boot</a></li>
					
					<li><a href="/tags/java-8">java 8</a></li>
					
					<li><a href="/tags/java-streams">java streams</a></li>
					
					<li><a href="/tags/ms-sql-server">ms sql server</a></li>
					
					<li><a href="/tags/spring-data">spring data</a></li>
					
					<li><a href="/tags/apache-kafka">apache kafka</a></li>
					
					<li><a href="/tags/sql">SQL</a></li>
					
					<li><a href="/tags/database-stored-procedures">database stored procedures</a></li>
					
					<li><a href="/tags/data-ingestion">data ingestion</a></li>
					
					<li><a href="/tags/data-processing">data processing</a></li>
					
					<li><a href="/tags/data-pipelines">data pipelines</a></li>
					
				</ul>
			</nav>
			
			
		</div>
	</article>
</main>
<footer>
  <div style="display:flex"><a class="soc" href="https://www.linkedin.com/in/lprakashv/" title="Linkedin"><i data-feather="linkedin"></i></a>
    <a class="border"></a><a class="soc" href="https://github.com/lprakashv" title="GitHub"><i data-feather="github"></i></a>
    <a class="border"></a><a class="soc" href="https://twitter.com/lprakashv/" title="Twitter"><i data-feather="twitter"></i></a>
    <a class="border"></a><a class="soc" href="https://stackoverflow.com/users/4066802/lprakashv?tab=profile" title="stackoverflow"><i data-feather="stackoverflow"></i></a>
    <a class="border"></a></div>
  <div class="footer-info">
    2022  © Lalit Prakash Vatsal |  
  </div>
</footer>


<script>
  feather.replace()
</script></div>
        <div class="content-side">
          <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3468549466738898"
     crossorigin="anonymous"></script>

<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3468549466738898"
     data-ad-slot="6861065745"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

        </div>
    </body>
</html>
