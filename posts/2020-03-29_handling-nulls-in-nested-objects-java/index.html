<!doctype html><html><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><title>Handling Nulls in nested objects (Java) - LALIT's TECH BLOG</title>
<link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><meta name=viewport content="width=device-width,initial-scale=1"><script async src="https://www.googletagmanager.com/gtag/js?id=G-DNE09NG226"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-DNE09NG226")</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3468549466738898" crossorigin=anonymous></script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3468549466738898" crossorigin=anonymous></script><meta name=description content="Handling NullPointerException and keeping track of all the nullable values has always been a pain for Java developers.
This is even worse when you are working with deeply nested objects and handling all the null values grows exponentially with each nullable nested value. This is visible by all the statements like:
if (x.y().z().. != null) {…} In this article, we will explore some of the techniques starting with the naive approach to a more advanced one for handling such scenarios."><meta property="og:image" content><meta property="og:title" content="Handling Nulls in nested objects (Java)"><meta property="og:description" content="Handling NullPointerException and keeping track of all the nullable values has always been a pain for Java developers.
This is even worse when you are working with deeply nested objects and handling all the null values grows exponentially with each nullable nested value. This is visible by all the statements like:
if (x.y().z().. != null) {…} In this article, we will explore some of the techniques starting with the naive approach to a more advanced one for handling such scenarios."><meta property="og:type" content="article"><meta property="og:url" content="https://www.lprakashv.com/posts/2020-03-29_handling-nulls-in-nested-objects-java/"><meta property="og:image" content="https://www.lprakashv.com/posts/2020-03-29_handling-nulls-in-nested-objects-java/images/1.png"><meta property="og:image" content="https://www.lprakashv.com/posts/2020-03-29_handling-nulls-in-nested-objects-java/images/2.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-03-29T09:14:32+00:00"><meta property="article:modified_time" content="2022-08-13T01:14:51+05:30"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.lprakashv.com/posts/2020-03-29_handling-nulls-in-nested-objects-java/images/1.png"><meta name=twitter:title content="Handling Nulls in nested objects (Java)"><meta name=twitter:description content="Handling NullPointerException and keeping track of all the nullable values has always been a pain for Java developers.
This is even worse when you are working with deeply nested objects and handling all the null values grows exponentially with each nullable nested value. This is visible by all the statements like:
if (x.y().z().. != null) {…} In this article, we will explore some of the techniques starting with the naive approach to a more advanced one for handling such scenarios."><script src=https://www.lprakashv.com/js/feather.min.js></script><link href=https://www.lprakashv.com/css/fonts.b685ac6f654695232de7b82a9143a46f9e049c8e3af3a21d9737b01f4be211d1.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://www.lprakashv.com/css/main.42a94afe1d883ff4fcef4d850a21c8e0c6903e7b33798d5ca18916cbd645a78a.css></head><body><div class=content><header><div class=main><div style=display:flex;flex-direction:row><img src=../../Lalit-new-logo.png style=border-color:#fff;border-radius:10px;width:150px><div style=margin:auto><a href=https://www.lprakashv.com/ style=font-size:2vh;font-weight:700>LALIT's TECH BLOG</a></div></div></div><nav><a href=../../>Home</a>
<a href=../../posts>All posts</a>
<a href=../../about>About</a>
<a href=../../tags>Tags</a></nav></header><main><article><div class=title><h1 class=title>Handling Nulls in nested objects (Java)</h1><div class=meta>Posted on Mar 29, 2020</div></div><section class=body><p><img src=../../posts/2020-03-29_handling-nulls-in-nested-objects-java/images/1.png#layoutTextWidth alt=image></p><p>Handling NullPointerException and keeping track of all the nullable values has always been a pain for Java developers.</p><p>This is even worse when you are working with deeply nested objects and handling all the null values grows exponentially with each nullable nested value. This is visible by all the statements like:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#080;font-weight:700>if</span><span style=color:#bbb> </span>(x.<span style=color:#00c>y</span>().<span style=color:#00c>z</span>()..<span style=color:#bbb> </span><span style=color:#333>!=</span><span style=color:#bbb> </span><span style=color:#080;font-weight:700>null</span>)<span style=color:#bbb> </span>{<span style=color:red;background-color:#faa>…</span>}<span style=color:#bbb>
</span></span></span></code></pre></div><p>In this article, we will explore some of the techniques starting with the naive approach to a more advanced one for handling such scenarios.So, are you ready? Let’s dive in…</p><p>Suppose we have a simple but nested object structure like:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>root {
</span></span><span style=display:flex><span>  first-level {
</span></span><span style=display:flex><span>    second-level {
</span></span><span style=display:flex><span>      third-level {
</span></span><span style=display:flex><span>        name: &#34;string&#34;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>where each object and/or value can be nullable. Say our objective is to create a greeting for the name nested three level deep behind root object.</p><p>Here are our test objects with our testing code:</p><script src=https://gist.github.com/lprakashv/57284252c43370da7a47fe2a361d43ef.js></script><p>Let’s start with the solutions:</p><h3 id=unsafe-approach><strong>Unsafe Approach:</strong></h3><script src=https://gist.github.com/lprakashv/38af049e1d4971a31a7cd8a394fd1b74.js></script><p>This can result in a NullPointerException!</p><p>Result:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>Failed to greet for r1 !
</span></span><span style=display:flex><span>Failed to greet for r2 !
</span></span><span style=display:flex><span>Failed to greet for r3 !
</span></span><span style=display:flex><span>Greeting for r4 : Hello null
</span></span><span style=display:flex><span>Greeting for r5 : Hello Lalit
</span></span></code></pre></div><h3 id=naive-safe-approach><strong>Naive Safe Approach:</strong></h3><script src=https://gist.github.com/lprakashv/f68f7f55cb60e42562a0e47a594c856f.js></script><p>Result:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>Greeting for r1 : Hey There!
</span></span><span style=display:flex><span>Greeting for r2 : Hey There!
</span></span><span style=display:flex><span>Greeting for r3 : Hey There!
</span></span><span style=display:flex><span>Greeting for r4 : Hey There!
</span></span><span style=display:flex><span>Greeting for r5 : Hello Lalit
</span></span></code></pre></div><p>Look at the indentation increasing with the increasing nesting level. Although, we could combine the null checks, but if we wanted to do other operation on each nested object then we would have to adopt the above approach.</p><h3 id=the-optional-approach><strong>The Optional Approach</strong></h3><script src=https://gist.github.com/lprakashv/71d96300fb967d53825895b32351c1f7.js></script><p>Now, we will jump into the functional territory to solve this problem. Java 8’s Optional&lt;T&lt; comes to our rescue:</p><p>This works like a charm! The only problem is we cannot control and determine which stage failed or is null, and cannot have failover for each stage.</p><p>To implement that in Optional, we have to do like:</p><script src=https://gist.github.com/lprakashv/5e446053cd0c236aca7d496fa987642e.js></script><p>Result:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>Greeting for r1 : Hello first level is null
</span></span><span style=display:flex><span>Greeting for r2 : Hello second level null
</span></span><span style=display:flex><span>Greeting for r3 : Hello third level is null
</span></span><span style=display:flex><span>Greeting for r4 : Hey There!
</span></span><span style=display:flex><span>Greeting for r5 : Hello Lalit
</span></span></code></pre></div><p>This will work, but we had to write a lot of orElse statements to handle a particular null case and we have to be careful as to where we want to put them.</p><p>What if there was a way to pass a default at each map stage…?</p><h3 id=custom-wrapper-approach><strong>Custom Wrapper Approach</strong></h3><p>Let’s write our own NullableWrapper with mapper taking a default value at each map stage (We’ll consider null otherwise). Let’s call our object as NullableWrapper&lt;T&lt; which:</p><ol><li>Takes a <strong>supplier</strong> returning a value of type T (denoting lazy computation) or a value of type T.</li><li><strong>May take</strong> a <strong>default value</strong> of type T (if the supplier or value results in null) which is by default set to null.</li><li>Can <strong>map</strong> the current wrapper&lt;T&lt; to new wrapper&lt;R&lt; by providing a transforming function Function&lt;T,R&lt; and <strong>may take</strong> a <strong>new default value</strong> of type R which is otherwise set to null.</li><li>Can <strong>get</strong> the value by providing a <strong>new default value</strong> of type T which is otherwise set to null.</li></ol><p>Now we have all the ingredients for the recipe, let’s start cooking!</p><script src=https://gist.github.com/lprakashv/9c8b6e5db3c96f992724159524f2a36d.js></script><p>Now, let’s taste it! I mean test it with the <strong>mapWithDefault</strong> feature (the other map will work exactly like Optional).</p><script src=https://gist.github.com/lprakashv/d92be758bbffd36928f9330d6ea5f150.js></script><p>This will also work just like we expected, and the code looks more elegant.</p><p>One more benefit of this is that <strong>we don’t have to use the getOrElse every time as NullableWrapper’s .get() will return a default value or null</strong> (in case default not provided) instead of blowing up:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#888>// will blow up!</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>Optional.<span style=color:#00c>ofNullable</span>(<span style=color:#080;font-weight:700>null</span>).<span style=color:#00c>map</span>(x<span style=color:#bbb> </span><span style=color:#333>-&gt;</span><span style=color:#bbb> </span><span style=background-color:#fff0f0>&#34;Hello &#34;</span><span style=color:#bbb> </span><span style=color:#333>+</span><span style=color:#bbb> </span>x).<span style=color:#00c>get</span>();<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#888>// will return null</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-weight:700>new</span><span style=color:#bbb> </span>NullableWrapper(()<span style=color:#bbb> </span><span style=color:#333>-&lt;</span><span style=color:#bbb> </span><span style=color:#080;font-weight:700>null</span>).<span style=color:#00c>map</span>(x<span style=color:#bbb> </span><span style=color:#333>-&gt;</span><span style=color:#bbb> </span><span style=background-color:#fff0f0>&#34;Hello &#34;</span><span style=color:#bbb> </span><span style=color:#333>+</span><span style=color:#bbb> </span>x).<span style=color:#00c>get</span>();<span style=color:#bbb>
</span></span></span></code></pre></div><p>Now, let’s see the NullableWrapper&#171;() from the point of view of a library user. It asks for a supplier or a value of type T and a default value.</p><p>This makes me think that the <strong>supplier evaluation must also be safe</strong> as it would be lazily evaluated inside the wrapper! Let’s try it out:</p><script src=https://gist.github.com/lprakashv/8132c283fc608077bbbb6835d3d71773.js></script><p>Result:</p><p><img src=../../posts/2020-03-29_handling-nulls-in-nested-objects-java/images/2.png#layoutTextWidth alt=image></p><p>Uh oh! What happened there?</p><p>This means the .get() operation is not that safe as we thought! How to make it safe? Let’s try to fix this by gulping all the NPEs:</p><script src=https://gist.github.com/lprakashv/9333bc660e955883cbc61167a289aad4.js></script><p>Now, we also want to do mapping by ignoring NPEs:</p><script src=https://gist.github.com/lprakashv/959dda9f696f099105ebc22f9054cb8a.js></script><p>Let’s try that again:</p><script src=https://gist.github.com/lprakashv/36fcc9f772c38b0b5ef05c6852b031a5.js></script><p>Result:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>Hey There!
</span></span><span style=display:flex><span>Hi Lalit
</span></span></code></pre></div><h2 id=conclusion>Conclusion</h2><p>We saw how we can utilise the power of Optionals and functional programming concepts to get the safety of the null checks as well as the control over the outcome with a default value.</p><p>Our own NullableWrapper gives following advantages over builtin Optional:</p><ul><li>Mapping with a default value at any stage.</li><li>Defining initial default value.</li><li>Super safe lazy computation by ignoring NPEs.</li><li>Safer than NullableWrapper’s get() is more safer than Optional’s get() as it will return null or a default value as the final result and won’t just blow up.</li></ul><p>Hope you liked it. Thanks for reading :)</p></section><div class=post-tags><nav class="nav tags"><ul class=tags><li><a href=../../tags/java>java</a></li><li><a href=../../tags/nulls>nulls</a></li><li><a href=../../tags/null-pointer-exception>null pointer exception</a></li><li><a href=../../tags/error-handling>error handling</a></li><li><a href=../../tags/java-8>java 8</a></li><li><a href=../../tags/java-streams>java streams</a></li></ul></nav></div><script id=diffblog-plugin-script async src=https://diff.blog/static/js/diffblog_plugin_v1.js></script><script>document.getElementById("diffblog-plugin-script").addEventListener("load",function(){DiffBlog("hhv3f1602vgc1ljqid62utggmyom9g2ujt9tm6gw74msobue5n")})</script><div id=disqus_thread></div><script>(function(){var e=document,t=e.createElement("script");t.src="https://lprakashv-tech-blog.disqus.com/embed.js",t.setAttribute("data-timestamp",+new Date),(e.head||e.body).appendChild(t)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></article></main><footer><div style=display:flex><a class=soc href=https://www.linkedin.com/in/lprakashv/ title=Linkedin><i data-feather=linkedin></i></a>
<a class=border></a><a class=soc href=https://github.com/lprakashv title=GitHub><i data-feather=github></i></a>
<a class=border></a><a class=soc href=https://twitter.com/lprakashv/ title=Twitter><i data-feather=twitter></i></a>
<a class=border></a><a class=soc href="https://stackoverflow.com/users/4066802/lprakashv?tab=profile" title=stackoverflow><i data-feather=stackoverflow></i></a>
<a class=border></a></div><div class=footer-info>2024 © Lalit Prakash Vatsal |</div></footer><script>feather.replace()</script></div></body></html>