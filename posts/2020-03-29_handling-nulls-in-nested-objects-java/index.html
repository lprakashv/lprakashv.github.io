<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>Handling Nulls in nested objects (Java) - LPRAKASHV TECH BLOG</title><meta name=viewport content="width=device-width,initial-scale=1"><script async src="https://www.googletagmanager.com/gtag/js?id=G-EJ9HBFC442"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-EJ9HBFC442")</script><meta name=description content="Handling NullPointerException and keeping track of all the nullable values has always been a pain for Java developers.
This is even worse when you are working with deeply nested objects and handling all the null values grows exponentially with each nullable nested value. This is visible by all the statements like:
if (x.y().z().. != null) {…} In this article, we will explore some of the techniques starting with the naive approach to a more advanced one for handling such scenarios."><meta property="og:image" content><meta property="og:title" content="Handling Nulls in nested objects (Java)"><meta property="og:description" content="Handling NullPointerException and keeping track of all the nullable values has always been a pain for Java developers.
This is even worse when you are working with deeply nested objects and handling all the null values grows exponentially with each nullable nested value. This is visible by all the statements like:
if (x.y().z().. != null) {…} In this article, we will explore some of the techniques starting with the naive approach to a more advanced one for handling such scenarios."><meta property="og:type" content="article"><meta property="og:url" content="https://www.lprakashv.com/posts/2020-03-29_handling-nulls-in-nested-objects-java/"><meta property="og:image" content="https://www.lprakashv.com/posts/2020-03-29_handling-nulls-in-nested-objects-java/images/1.png"><meta property="og:image" content="https://www.lprakashv.com/posts/2020-03-29_handling-nulls-in-nested-objects-java/images/2.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-03-29T09:14:32+00:00"><meta property="article:modified_time" content="2022-08-13T01:14:51+05:30"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.lprakashv.com/posts/2020-03-29_handling-nulls-in-nested-objects-java/images/1.png"><meta name=twitter:title content="Handling Nulls in nested objects (Java)"><meta name=twitter:description content="Handling NullPointerException and keeping track of all the nullable values has always been a pain for Java developers.
This is even worse when you are working with deeply nested objects and handling all the null values grows exponentially with each nullable nested value. This is visible by all the statements like:
if (x.y().z().. != null) {…} In this article, we will explore some of the techniques starting with the naive approach to a more advanced one for handling such scenarios."><script src=https://www.lprakashv.com/js/feather.min.js></script>
<link href=https://www.lprakashv.com/css/fonts.b685ac6f654695232de7b82a9143a46f9e049c8e3af3a21d9737b01f4be211d1.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://www.lprakashv.com/css/main.c854a9a2c53b1afadf31c3b562cfc34963b1caa5a9def32de484552e8dbdae30.css></head><body><div class=content-side><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3468549466738898" crossorigin=anonymous></script>
<ins class=adsbygoogle style=display:block data-ad-client=ca-pub-3468549466738898 data-ad-slot=6861065745 data-ad-format=auto data-full-width-responsive=true></ins>
<script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><div class=content><header><div class=main><a href=https://www.lprakashv.com/>LPRAKASHV TECH BLOG</a></div><nav><a href=/>Home</a>
<a href=/posts>All posts</a>
<a href=https://github.com/lprakashv/lprakashv>About</a>
<a href=/tags>Tags</a></nav></header><main><article><div class=title><h1 class=title>Handling Nulls in nested objects (Java)</h1><div class=meta>Posted on Mar 29, 2020</div></div><section class=body><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3468549466738898" crossorigin=anonymous></script>
<ins class=adsbygoogle style=display:block data-ad-client=ca-pub-3468549466738898 data-ad-slot=5126431802 data-ad-format=auto data-full-width-responsive=true></ins>
<script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><p><img src=/posts/2020-03-29_handling-nulls-in-nested-objects-java/images/1.png#layoutTextWidth alt=image></p><p>Handling NullPointerException and keeping track of all the nullable values has always been a pain for Java developers.</p><p>This is even worse when you are working with deeply nested objects and handling all the null values grows exponentially with each nullable nested value. This is visible by all the statements like:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>x<span style=color:#f92672>.</span><span style=color:#a6e22e>y</span><span style=color:#f92672>().</span><span style=color:#a6e22e>z</span><span style=color:#f92672>()..</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span><span style=color:#960050;background-color:#1e0010>…</span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>In this article, we will explore some of the techniques starting with the naive approach to a more advanced one for handling such scenarios.So, are you ready? Let’s dive in…</p><p>Suppose we have a simple but nested object structure like:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>root {
</span></span><span style=display:flex><span>  first-level {
</span></span><span style=display:flex><span>    second-level {
</span></span><span style=display:flex><span>      third-level {
</span></span><span style=display:flex><span>        name: &#34;string&#34;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>where each object and/or value can be nullable. Say our objective is to create a greeting for the name nested three level deep behind root object.</p><p>Here are our test objects with our testing code:</p><script type=application/javascript src=https://gist.github.com/lprakashv/57284252c43370da7a47fe2a361d43ef.js></script><p>Let’s start with the solutions:</p><h3 id=unsafe-approach><strong>Unsafe Approach:</strong></h3><script type=application/javascript src=https://gist.github.com/lprakashv/38af049e1d4971a31a7cd8a394fd1b74.js></script><p>This can result in a NullPointerException!</p><p>Result:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>Failed to greet for r1 !
</span></span><span style=display:flex><span>Failed to greet for r2 !
</span></span><span style=display:flex><span>Failed to greet for r3 !
</span></span><span style=display:flex><span>Greeting for r4 : Hello null
</span></span><span style=display:flex><span>Greeting for r5 : Hello Lalit
</span></span></code></pre></div><h3 id=naive-safe-approach><strong>Naive Safe Approach:</strong></h3><script type=application/javascript src=https://gist.github.com/lprakashv/f68f7f55cb60e42562a0e47a594c856f.js></script><p>Result:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>Greeting for r1 : Hey There!
</span></span><span style=display:flex><span>Greeting for r2 : Hey There!
</span></span><span style=display:flex><span>Greeting for r3 : Hey There!
</span></span><span style=display:flex><span>Greeting for r4 : Hey There!
</span></span><span style=display:flex><span>Greeting for r5 : Hello Lalit
</span></span></code></pre></div><p>Look at the indentation increasing with the increasing nesting level. Although, we could combine the null checks, but if we wanted to do other operation on each nested object then we would have to adopt the above approach.</p><h3 id=the-optional-approach><strong>The Optional Approach</strong></h3><script type=application/javascript src=https://gist.github.com/lprakashv/71d96300fb967d53825895b32351c1f7.js></script><p>Now, we will jump into the functional territory to solve this problem. Java 8’s Optional&lt;T&lt; comes to our rescue:</p><p>This works like a charm! The only problem is we cannot control and determine which stage failed or is null, and cannot have failover for each stage.</p><p>To implement that in Optional, we have to do like:</p><script type=application/javascript src=https://gist.github.com/lprakashv/5e446053cd0c236aca7d496fa987642e.js></script><p>Result:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>Greeting for r1 : Hello first level is null
</span></span><span style=display:flex><span>Greeting for r2 : Hello second level null
</span></span><span style=display:flex><span>Greeting for r3 : Hello third level is null
</span></span><span style=display:flex><span>Greeting for r4 : Hey There!
</span></span><span style=display:flex><span>Greeting for r5 : Hello Lalit
</span></span></code></pre></div><p>This will work, but we had to write a lot of orElse statements to handle a particular null case and we have to be careful as to where we want to put them.</p><p>What if there was a way to pass a default at each map stage…?</p><h3 id=custom-wrapper-approach><strong>Custom Wrapper Approach</strong></h3><p>Let’s write our own NullableWrapper with mapper taking a default value at each map stage (We’ll consider null otherwise). Let’s call our object as NullableWrapper&lt;T&lt; which:</p><ol><li>Takes a <strong>supplier</strong> returning a value of type T (denoting lazy computation) or a value of type T.</li><li><strong>May take</strong> a <strong>default value</strong> of type T (if the supplier or value results in null) which is by default set to null.</li><li>Can <strong>map</strong> the current wrapper&lt;T&lt; to new wrapper&lt;R&lt; by providing a transforming function Function&lt;T,R&lt; and <strong>may take</strong> a <strong>new default value</strong> of type R which is otherwise set to null.</li><li>Can <strong>get</strong> the value by providing a <strong>new default value</strong> of type T which is otherwise set to null.</li></ol><p>Now we have all the ingredients for the recipe, let’s start cooking!</p><script type=application/javascript src=https://gist.github.com/lprakashv/9c8b6e5db3c96f992724159524f2a36d.js></script><p>Now, let’s taste it! I mean test it with the <strong>mapWithDefault</strong> feature (the other map will work exactly like Optional).</p><script type=application/javascript src=https://gist.github.com/lprakashv/d92be758bbffd36928f9330d6ea5f150.js></script><p>This will also work just like we expected, and the code looks more elegant.</p><p>One more benefit of this is that <strong>we don’t have to use the getOrElse every time as NullableWrapper’s .get() will return a default value or null</strong> (in case default not provided) instead of blowing up:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// will blow up!
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>Optional<span style=color:#f92672>.</span><span style=color:#a6e22e>ofNullable</span><span style=color:#f92672>(</span><span style=color:#66d9ef>null</span><span style=color:#f92672>).</span><span style=color:#a6e22e>map</span><span style=color:#f92672>(</span>x <span style=color:#f92672>-&gt;</span> <span style=color:#e6db74>&#34;Hello &#34;</span> <span style=color:#f92672>+</span> x<span style=color:#f92672>).</span><span style=color:#a6e22e>get</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// will return null
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>new</span> NullableWrapper<span style=color:#f92672>(()</span> <span style=color:#f92672>-&lt;</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>).</span><span style=color:#a6e22e>map</span><span style=color:#f92672>(</span>x <span style=color:#f92672>-&gt;</span> <span style=color:#e6db74>&#34;Hello &#34;</span> <span style=color:#f92672>+</span> x<span style=color:#f92672>).</span><span style=color:#a6e22e>get</span><span style=color:#f92672>();</span>
</span></span></code></pre></div><p>Now, let’s see the NullableWrapper&#171;() from the point of view of a library user. It asks for a supplier or a value of type T and a default value.</p><p>This makes me think that the <strong>supplier evaluation must also be safe</strong> as it would be lazily evaluated inside the wrapper! Let’s try it out:</p><script type=application/javascript src=https://gist.github.com/lprakashv/8132c283fc608077bbbb6835d3d71773.js></script><p>Result:</p><p><img src=/posts/2020-03-29_handling-nulls-in-nested-objects-java/images/2.png#layoutTextWidth alt=image></p><p>Uh oh! What happened there?</p><p>This means the .get() operation is not that safe as we thought! How to make it safe? Let’s try to fix this by gulping all the NPEs:</p><script type=application/javascript src=https://gist.github.com/lprakashv/9333bc660e955883cbc61167a289aad4.js></script><p>Now, we also want to do mapping by ignoring NPEs:</p><script type=application/javascript src=https://gist.github.com/lprakashv/959dda9f696f099105ebc22f9054cb8a.js></script><p>Let’s try that again:</p><script type=application/javascript src=https://gist.github.com/lprakashv/36fcc9f772c38b0b5ef05c6852b031a5.js></script><p>Result:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>Hey There!
</span></span><span style=display:flex><span>Hi Lalit
</span></span></code></pre></div><h2 id=conclusion>Conclusion</h2><p>We saw how we can utilise the power of Optionals and functional programming concepts to get the safety of the null checks as well as the control over the outcome with a default value.</p><p>Our own NullableWrapper gives following advantages over builtin Optional:</p><ul><li>Mapping with a default value at any stage.</li><li>Defining initial default value.</li><li>Super safe lazy computation by ignoring NPEs.</li><li>Safer than NullableWrapper’s get() is more safer than Optional’s get() as it will return null or a default value as the final result and won’t just blow up.</li></ul><p>Hope you liked it. Thanks for reading :)</p><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3468549466738898" crossorigin=anonymous></script>
<ins class=adsbygoogle style=display:block data-ad-client=ca-pub-3468549466738898 data-ad-slot=5126431802 data-ad-format=auto data-full-width-responsive=true></ins>
<script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></section><div class=post-tags><nav class="nav tags"><ul class=tags><li><a href=/tags/java>java</a></li><li><a href=/tags/nulls>nulls</a></li><li><a href=/tags/null-pointer-exception>null pointer exception</a></li><li><a href=/tags/error-handling>error handling</a></li><li><a href=/tags/java-8>java 8</a></li><li><a href=/tags/java-streams>java streams</a></li></ul></nav></div></article></main><footer><div style=display:flex><a class=soc href=https://www.linkedin.com/in/lprakashv/ title=Linkedin><i data-feather=linkedin></i></a>
<a class=border></a><a class=soc href=https://github.com/lprakashv title=GitHub><i data-feather=github></i></a>
<a class=border></a><a class=soc href=https://twitter.com/lprakashv/ title=Twitter><i data-feather=twitter></i></a>
<a class=border></a><a class=soc href="https://stackoverflow.com/users/4066802/lprakashv?tab=profile" title=stackoverflow><i data-feather=stackoverflow></i></a>
<a class=border></a></div><div class=footer-info>2022 © Lalit Prakash Vatsal |</div></footer><script>feather.replace()</script></div><div class=content-side><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3468549466738898" crossorigin=anonymous></script>
<ins class=adsbygoogle style=display:block data-ad-client=ca-pub-3468549466738898 data-ad-slot=6861065745 data-ad-format=auto data-full-width-responsive=true></ins>
<script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div></body></html>