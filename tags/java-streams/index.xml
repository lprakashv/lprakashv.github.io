<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>java streams on LPRAKASHV TECH BLOG</title><link>https://www.lprakashv.com/tags/java-streams/</link><description>Recent content in java streams on LPRAKASHV TECH BLOG</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>© Lalit Prakash Vatsal</copyright><lastBuildDate>Tue, 25 May 2021 11:30:29 +0000</lastBuildDate><atom:link href="https://www.lprakashv.com/tags/java-streams/index.xml" rel="self" type="application/rss+xml"/><item><title>Better Switch-Case for Java!</title><link>https://www.lprakashv.com/posts/2021-05-25_better-switchcase-for-java/</link><pubDate>Tue, 25 May 2021 11:30:29 +0000</pubDate><guid>https://www.lprakashv.com/posts/2021-05-25_better-switchcase-for-java/</guid><description>Let’s start with the question, what is wrong with the switch-case anyway? Here’s a simple example of a switch-case in Java:
Can you see the problem here? It is the unnecessary “ceremony” of writing the “break” statement on each case!
You can argue that we can just return after each case-block, while this is a brilliant idea but, then the ceremony would be of writing “return” in each block 😜 you can even miss that!</description></item><item><title>Bulk RDBMS Upserts with Spring</title><link>https://www.lprakashv.com/posts/2020-08-28_bulk-rdbms-upserts-with-spring/</link><pubDate>Fri, 28 Aug 2020 21:08:07 +0000</pubDate><guid>https://www.lprakashv.com/posts/2020-08-28_bulk-rdbms-upserts-with-spring/</guid><description>Upsert is a fairly common terminology in databases, meaning Update if the record exists or Insert the new record. Upserts make more sense in case of simple object save requests with new information.
Why Bulk? If we talk about any data sync, data migration or bulk data update jobs, we are bound to have a bulk upsert scenario to update whatever we have in the database and insert all the new rows.</description></item><item><title>Handling Nulls in nested objects (Java)</title><link>https://www.lprakashv.com/posts/2020-03-29_handling-nulls-in-nested-objects-java/</link><pubDate>Sun, 29 Mar 2020 09:14:32 +0000</pubDate><guid>https://www.lprakashv.com/posts/2020-03-29_handling-nulls-in-nested-objects-java/</guid><description>Handling NullPointerException and keeping track of all the nullable values has always been a pain for Java developers.
This is even worse when you are working with deeply nested objects and handling all the null values grows exponentially with each nullable nested value. This is visible by all the statements like:
if (x.y().z().. != null) {…} In this article, we will explore some of the techniques starting with the naive approach to a more advanced one for handling such scenarios.</description></item><item><title>Cushing Design Patterns! — Unnecessary Patterns.</title><link>https://www.lprakashv.com/posts/2019-09-30_cushing-design-patternsunnecessary-patterns./</link><pubDate>Mon, 30 Sep 2019 05:16:43 +0000</pubDate><guid>https://www.lprakashv.com/posts/2019-09-30_cushing-design-patternsunnecessary-patterns./</guid><description>This is the part-II in the continuation of the “Crushing Design Patterns” series (Part-I) where we debunk the idea of having to use the design patterns to design the system.
Intro They are either just so natural that we have been using them unconsciously or there are better ways in which we don’t have to focus on ceremoniously writing them.Here we go.
1. Builder Pattern The intent of the Builder design pattern is to separate the construction of a complex object from its representation.</description></item></channel></rss>